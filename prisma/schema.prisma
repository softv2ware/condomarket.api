// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  PLATFORM_ADMIN
  BUILDING_ADMIN
  RESIDENT
}

enum UserStatus {
  PENDING
  VERIFIED
  SUSPENDED
  BANNED
}

enum BuildingType {
  APARTMENT_COMPLEX
  CONDOMINIUM
  GATED_COMMUNITY
  RESIDENTIAL_TOWER
  MIXED_USE
  OTHER
}

enum BuildingStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum VerificationMethod {
  INVITATION_CODE
  UNIT_CODE_LASTNAME
  MANUAL_APPROVAL
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  phone     String?    @unique
  password  String
  role      UserRole   @default(RESIDENT)
  status    UserStatus @default(PENDING)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  profile               UserProfile?
  residences            ResidentBuilding[]
  managedBuildings      Building[]               @relation("BuildingAdmin")
  createdInvitations    InvitationCode[]         @relation("InvitationCreator")
  usedInvitation        InvitationCode?          @relation("InvitationUser")
  verificationsApproved ResidentBuilding[]       @relation("VerificationApprover")
  subscriptions         SellerSubscription[]
  paymentMethods        PaymentMethod[]
  listings              Listing[]
  listingViews          ListingView[]
  savedListings         SavedListing[]
  ordersBought          Order[]                  @relation("OrderBuyer")
  ordersSold            Order[]                  @relation("OrderSeller")
  bookingsBought        Booking[]                @relation("BookingBuyer")
  bookingsSold          Booking[]                @relation("BookingSeller")
  messages              Message[]
  reviewsGiven          Review[]                 @relation("ReviewsGiven")
  reviewsReceived       Review[]                 @relation("ReviewsReceived")
  notifications         Notification[]
  notificationPrefs     NotificationPreference[]
  deviceTokens          DeviceToken[]

  @@map("users")
}

model UserProfile {
  id                     String   @id @default(uuid())
  userId                 String   @unique
  user                   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  firstName              String?
  lastName               String?
  bio                    String?
  profilePictureUrl      String?
  privacySettings        Json?
  acceptedPaymentMethods String[]
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  @@map("user_profiles")
}

model Building {
  id          String         @id @default(uuid())
  name        String
  address     String
  city        String?
  state       String?
  zipCode     String?
  country     String?        @default("USA")
  type        BuildingType   @default(APARTMENT_COMPLEX)
  status      BuildingStatus @default(ACTIVE)
  description String?
  adminId     String?
  admin       User?          @relation("BuildingAdmin", fields: [adminId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  units               Unit[]
  residents           ResidentBuilding[]
  invitationCodes     InvitationCode[]
  subscriptionPlans   SubscriptionPlan[]
  sellerSubscriptions SellerSubscription[]
  categories          Category[]
  listings            Listing[]
  orders              Order[]              @relation("OrderBuilding")
  bookings            Booking[]            @relation("BookingBuilding")

  @@index([status])
  @@index([adminId])
  @@map("buildings")
}

model Unit {
  id         String   @id @default(uuid())
  buildingId String
  building   Building @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  unitNumber String
  floor      Int?
  type       String? // Studio, 1BR, 2BR, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  residents ResidentBuilding[]

  @@unique([buildingId, unitNumber])
  @@index([buildingId])
  @@map("units")
}

model ResidentBuilding {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  buildingId String
  building   Building @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  unitId     String?
  unit       Unit?    @relation(fields: [unitId], references: [id], onDelete: SetNull)

  verificationMethod VerificationMethod?
  verificationStatus VerificationStatus  @default(PENDING)
  verificationData   Json? // Store additional verification info
  verifiedAt         DateTime?
  verifiedBy         String?
  verifier           User?               @relation("VerificationApprover", fields: [verifiedBy], references: [id])

  moveInDate  DateTime?
  moveOutDate DateTime?
  isActive    Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, buildingId])
  @@index([buildingId])
  @@index([userId])
  @@index([verificationStatus])
  @@map("resident_buildings")
}

model InvitationCode {
  id         String    @id @default(uuid())
  buildingId String
  building   Building  @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  code       String    @unique
  createdBy  String
  creator    User      @relation("InvitationCreator", fields: [createdBy], references: [id])
  usedBy     String?   @unique
  usedByUser User?     @relation("InvitationUser", fields: [usedBy], references: [id])
  usedAt     DateTime?
  expiresAt  DateTime?
  isActive   Boolean   @default(true)

  createdAt DateTime @default(now())

  @@index([buildingId])
  @@index([code])
  @@index([isActive])
  @@map("invitation_codes")
}

enum SubscriptionTier {
  FREE
  STANDARD
  PREMIUM
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAYMENT_FAILED
  GRACE_PERIOD
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum PaymentMethodType {
  CREDIT_CARD
  DEBIT_CARD
  BANK_ACCOUNT
  PAYPAL
  OTHER
}

model SubscriptionPlan {
  id                 String           @id @default(uuid())
  name               String
  tier               SubscriptionTier @unique
  description        String?
  monthlyPrice       Float            @default(0)
  currency           String           @default("USD")
  maxActiveListings  Int              @default(1)
  sortPriority       Int              @default(0) // Higher = better placement in search
  isHighlightEnabled Boolean          @default(false) // Premium feature
  isDefaultFree      Boolean          @default(false) // Auto-assign this plan to new users
  buildingId         String? // null = platform-wide, else building-specific
  building           Building?        @relation(fields: [buildingId], references: [id], onDelete: Cascade)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions SellerSubscription[]

  @@index([tier])
  @@index([buildingId])
  @@index([isActive])
  @@map("subscription_plans")
}

model SellerSubscription {
  id         String           @id @default(uuid())
  userId     String
  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  buildingId String
  building   Building         @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  planId     String
  plan       SubscriptionPlan @relation(fields: [planId], references: [id])

  status            SubscriptionStatus @default(ACTIVE)
  startDate         DateTime           @default(now())
  endDate           DateTime? // null = ongoing
  renewsAt          DateTime? // Next renewal date
  lastPaymentStatus PaymentStatus?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payments SubscriptionPayment[]
  logs     SubscriptionLog[]

  @@unique([userId, buildingId]) // One subscription per user per building
  @@index([userId])
  @@index([buildingId])
  @@index([planId])
  @@index([status])
  @@map("seller_subscriptions")
}

model PaymentMethod {
  id         String            @id @default(uuid())
  userId     String
  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  type       PaymentMethodType
  provider   String // e.g., "Stripe", "PayPal"
  externalId String? // ID from payment provider
  last4      String? // Last 4 digits of card
  isDefault  Boolean           @default(false)
  isActive   Boolean           @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("payment_methods")
}

model SubscriptionPayment {
  id             String             @id @default(uuid())
  subscriptionId String
  subscription   SellerSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  amount         Float
  currency       String             @default("USD")
  status         PaymentStatus      @default(PENDING)
  paidAt         DateTime?
  failureReason  String?
  externalId     String? // Payment provider transaction ID

  createdAt DateTime @default(now())

  @@index([subscriptionId])
  @@index([status])
  @@map("subscription_payments")
}

model SubscriptionLog {
  id             String             @id @default(uuid())
  subscriptionId String
  subscription   SellerSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  action         String // e.g., "created", "renewed", "cancelled", "upgraded", "downgraded"
  oldStatus      String?
  newStatus      String?
  metadata       Json? // Additional context

  createdAt DateTime @default(now())

  @@index([subscriptionId])
  @@index([action])
  @@map("subscription_logs")
}

// ============================================
// STAGE 4: MARKETPLACE LISTINGS
// ============================================

enum ListingType {
  PRODUCT
  SERVICE
}

enum ListingStatus {
  DRAFT // Created but not published
  PENDING_APPROVAL // Submitted for moderation
  ACTIVE // Published and visible
  PAUSED // Temporarily hidden by seller
  REJECTED // Rejected by moderator
  EXPIRED // Past availability
  SOLD // Product sold
}

enum AvailabilityType {
  ALWAYS // Always available
  SCHEDULED // Service with scheduled times
  LIMITED_STOCK // Product with quantity
}

enum CategoryType {
  PRODUCT
  SERVICE
}

model Category {
  id          String       @id @default(uuid())
  name        String
  slug        String
  type        CategoryType
  description String?
  icon        String? // Icon name or emoji
  parentId    String? // For hierarchical categories
  parent      Category?    @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    Category[]   @relation("CategoryHierarchy")
  buildingId  String? // null = platform-wide, set = building-specific
  building    Building?    @relation(fields: [buildingId], references: [id], onDelete: Cascade)

  listings Listing[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([slug, buildingId])
  @@index([type])
  @@index([buildingId])
  @@index([parentId])
  @@map("categories")
}

model Listing {
  id         String   @id @default(uuid())
  sellerId   String
  seller     User     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  buildingId String
  building   Building @relation(fields: [buildingId], references: [id], onDelete: Cascade)

  type        ListingType
  title       String
  slug        String
  description String      @db.Text
  categoryId  String
  category    Category    @relation(fields: [categoryId], references: [id])

  price    Float
  currency String        @default("USD")
  status   ListingStatus @default(DRAFT)

  // Subscription tier snapshot at time of creation
  subscriptionTierSnapshot SubscriptionTier?

  // Availability info
  availabilityType  AvailabilityType @default(ALWAYS)
  pickupLocation    String? // For products
  deliveryAvailable Boolean          @default(false)
  durationMinutes   Int? // For services (e.g., 60 = 1 hour service)

  // Lifecycle
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?

  // Analytics
  viewCount  Int @default(0)
  orderCount Int @default(0)

  // Relations
  photos       ListingPhoto[]
  availability ListingAvailability[]
  views        ListingView[]
  savedBy      SavedListing[]
  orders       Order[]
  bookings     Booking[]
  reviews      Review[]

  @@unique([slug, buildingId])
  @@index([sellerId])
  @@index([buildingId])
  @@index([categoryId])
  @@index([type])
  @@index([status])
  @@index([subscriptionTierSnapshot])
  @@index([publishedAt])
  @@map("listings")
}

model ListingPhoto {
  id        String  @id @default(uuid())
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  url       String
  order     Int     @default(0)
  isMain    Boolean @default(false)

  createdAt DateTime @default(now())

  @@index([listingId])
  @@index([isMain])
  @@map("listing_photos")
}

model ListingAvailability {
  id        String  @id @default(uuid())
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  dayOfWeek Int // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  startTime String // Format: "HH:mm" (e.g., "09:00")
  endTime   String // Format: "HH:mm" (e.g., "17:00")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([listingId])
  @@index([dayOfWeek])
  @@map("listing_availability")
}

model ListingView {
  id        String   @id @default(uuid())
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  userId    String? // null if anonymous
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  viewedAt  DateTime @default(now())

  @@index([listingId])
  @@index([userId])
  @@index([viewedAt])
  @@map("listing_views")
}

model SavedListing {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  savedAt   DateTime @default(now())

  @@unique([userId, listingId])
  @@index([userId])
  @@index([listingId])
  @@map("saved_listings")
}

// ============================================
// ORDERS & BOOKINGS (Stage 5)
// ============================================

enum OrderStatus {
  PENDING_CONFIRMATION // Waiting for seller to confirm
  CONFIRMED // Seller confirmed, ready to proceed
  READY_FOR_PICKUP // Product ready for buyer to collect
  OUT_FOR_DELIVERY // Product out for delivery
  COMPLETED // Order completed
  CANCELLED // Cancelled by buyer or seller
  EXPIRED // Auto-expired (not confirmed within 48h)
}

enum BookingStatus {
  REQUESTED // Buyer requested booking
  CONFIRMED // Seller confirmed booking
  IN_PROGRESS // Service in progress
  COMPLETED // Service completed
  CANCELLED // Cancelled by either party
  NO_SHOW // Buyer didn't show up
}

enum TransactionStatus {
  PENDING // Payment pending
  COMPLETED // Payment completed
  FAILED // Payment failed
  REFUNDED // Payment refunded
}

enum TransactionPaymentMethod {
  CASH
  BANK_TRANSFER
  VENMO
  PAYPAL
  ZELLE
  CHECK
  OTHER
}

enum DeliveryMethod {
  PICKUP // Buyer picks up
  DELIVERY // Seller delivers
  MEETING_POINT // Meet at agreed location
}

model Order {
  id         String   @id @default(uuid())
  listingId  String
  listing    Listing  @relation(fields: [listingId], references: [id])
  buyerId    String
  buyer      User     @relation("OrderBuyer", fields: [buyerId], references: [id])
  sellerId   String
  seller     User     @relation("OrderSeller", fields: [sellerId], references: [id])
  buildingId String
  building   Building @relation("OrderBuilding", fields: [buildingId], references: [id])

  type       ListingType @default(PRODUCT)
  status     OrderStatus @default(PENDING_CONFIRMATION)
  quantity   Int         @default(1)
  totalPrice Float
  currency   String      @default("USD")

  deliveryMethod  DeliveryMethod
  pickupLocation  String?
  deliveryAddress String?

  scheduledFor DateTime? // When buyer wants to pickup/receive
  notes        String?   @db.Text

  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  confirmedAt        DateTime?
  completedAt        DateTime?
  cancelledAt        DateTime?
  cancellationReason String?   @db.Text

  statusHistory OrderStatusHistory[]
  transactions  Transaction[]
  chatThread    ChatThread?
  reviews       Review[]

  @@index([listingId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([buildingId])
  @@index([status])
  @@index([createdAt])
  @@map("orders")
}

model OrderStatusHistory {
  id        String      @id @default(uuid())
  orderId   String
  order     Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  status    OrderStatus
  changedBy String // userId
  reason    String?     @db.Text
  createdAt DateTime    @default(now())

  @@index([orderId])
  @@index([createdAt])
  @@map("order_status_history")
}

model Booking {
  id         String   @id @default(uuid())
  listingId  String
  listing    Listing  @relation(fields: [listingId], references: [id])
  buyerId    String
  buyer      User     @relation("BookingBuyer", fields: [buyerId], references: [id])
  sellerId   String
  seller     User     @relation("BookingSeller", fields: [sellerId], references: [id])
  buildingId String
  building   Building @relation("BookingBuilding", fields: [buildingId], references: [id])

  status          BookingStatus @default(REQUESTED)
  startTime       DateTime
  endTime         DateTime
  durationMinutes Int
  totalPrice      Float
  currency        String        @default("USD")

  location String?
  notes    String? @db.Text

  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  confirmedAt        DateTime?
  completedAt        DateTime?
  cancelledAt        DateTime?
  cancellationReason String?   @db.Text

  statusHistory BookingStatusHistory[]
  transactions  Transaction[]
  chatThread    ChatThread?
  reviews       Review[]

  @@index([listingId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([buildingId])
  @@index([status])
  @@index([startTime])
  @@index([endTime])
  @@index([createdAt])
  @@map("bookings")
}

model BookingStatusHistory {
  id        String        @id @default(uuid())
  bookingId String
  booking   Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  status    BookingStatus
  changedBy String // userId
  reason    String?       @db.Text
  createdAt DateTime      @default(now())

  @@index([bookingId])
  @@index([createdAt])
  @@map("booking_status_history")
}

model Transaction {
  id        String   @id @default(uuid())
  orderId   String?
  order     Order?   @relation(fields: [orderId], references: [id])
  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id])

  amount        Float
  currency      String                   @default("USD")
  paymentMethod TransactionPaymentMethod
  status        TransactionStatus        @default(PENDING)

  paidAt   DateTime?
  metadata Json? // Additional payment details
  notes    String?   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([bookingId])
  @@index([status])
  @@index([createdAt])
  @@map("transactions")
}

// ============================================================================
// STAGE 6: COMMUNICATION & REVIEWS
// ============================================================================

enum MessageType {
  TEXT
  SYSTEM
  IMAGE
  FILE
}

enum ReviewType {
  ORDER
  BOOKING
}

enum ReviewStatus {
  ACTIVE
  FLAGGED
  REMOVED
}

enum NotificationType {
  REGISTRATION
  VERIFICATION
  ORDER_PLACED
  ORDER_CONFIRMED
  ORDER_READY
  ORDER_DELIVERED
  ORDER_COMPLETED
  ORDER_CANCELLED
  BOOKING_REQUESTED
  BOOKING_CONFIRMED
  BOOKING_STARTED
  BOOKING_COMPLETED
  BOOKING_CANCELLED
  CHAT_MESSAGE
  REVIEW_RECEIVED
  REVIEW_RESPONSE
  SUBSCRIPTION_EXPIRING
  SUBSCRIPTION_EXPIRED
  SYSTEM_ANNOUNCEMENT
}

enum NotificationChannel {
  IN_APP
  EMAIL
  PUSH
}

model ChatThread {
  id        String   @id @default(uuid())
  orderId   String?  @unique
  order     Order?   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  bookingId String?  @unique
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  participantIds String[] // Array of user IDs
  lastMessageAt  DateTime?

  messages Message[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([bookingId])
  @@index([lastMessageAt])
  @@map("chat_threads")
}

model Message {
  id       String     @id @default(uuid())
  threadId String
  thread   ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation(fields: [senderId], references: [id])

  content  String      @db.Text
  type     MessageType @default(TEXT)
  metadata Json? // For images, files, etc.

  readBy String[] @default([]) // Array of user IDs who read the message

  sentAt    DateTime  @default(now())
  editedAt  DateTime?
  deletedAt DateTime?

  @@index([threadId])
  @@index([senderId])
  @@index([sentAt])
  @@map("messages")
}

model Review {
  id        String   @id @default(uuid())
  orderId   String?
  order     Order?   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  reviewerId String
  reviewer   User   @relation("ReviewsGiven", fields: [reviewerId], references: [id])

  revieweeId String
  reviewee   User   @relation("ReviewsReceived", fields: [revieweeId], references: [id])

  listingId String
  listing   Listing @relation(fields: [listingId], references: [id])

  rating   Int // 1-5 stars
  comment  String? @db.Text
  response String? @db.Text

  type   ReviewType
  status ReviewStatus @default(ACTIVE)

  createdAt   DateTime  @default(now())
  respondedAt DateTime?
  updatedAt   DateTime  @updatedAt

  @@unique([orderId, reviewerId])
  @@unique([bookingId, reviewerId])
  @@index([orderId])
  @@index([bookingId])
  @@index([reviewerId])
  @@index([revieweeId])
  @@index([listingId])
  @@index([status])
  @@index([createdAt])
  @@map("reviews")
}

model Notification {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String           @db.Text
  data    Json? // Additional context data

  channels NotificationChannel[] @default([IN_APP])

  readAt DateTime?
  sentAt DateTime  @default(now())

  @@index([userId])
  @@index([type])
  @@index([readAt])
  @@index([sentAt])
  @@map("notifications")
}

model NotificationPreference {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  channel NotificationChannel
  type    NotificationType
  enabled Boolean             @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, channel, type])
  @@index([userId])
  @@map("notification_preferences")
}

model DeviceToken {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  token        String   @unique
  deviceType   String? // 'ios', 'android', 'web'
  deviceName   String?
  lastUsedAt   DateTime @default(now())
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([token])
  @@map("device_tokens")
}
